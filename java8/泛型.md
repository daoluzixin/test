# 泛型(Generics)

本质是为了参数化类型,操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为**泛型类、泛型接口、泛型方法**。

**参数类型约束**: 可通过继承extends约束(其子类)  e.g. class printer<T extends Vehicle> 泛型类T只能是Vehicle的子类

**类型安全**: Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息(或者是强制转换后的信息)擦除，泛型信息不会进入到运行时阶段。 会在编译时报错,即下例中 list.get(0)依旧为整型而非字符串类型

e.g. `List<Object> list = new ArrayList<>();`

​		`list.add(12);`

​		`String item = (String) list.get(0);`

​		`item.sout;`	

​		上述代码会在运行时报错

### 优点

1.代码重用：编写更通用的算法，适用于多种数据类型。
2.消除强制类型转换：减少从集合中获取元素时的强制类型转换。

## 泛型类

使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。

**泛型的类型参数只能是类类型，不能是简单类型。**

## 泛型接口

```java
//定义一个泛型接口
public interface Generator<T> {
    public T next();
}
//接口的实现类
class FruitGenerator<T> implements Generator<T>{
    @Override
    public T next() {
        return null;
    }
}
```

## 泛型方法

<T>要提前声明

```java
private static <T> void print(T content){
    System.out.println(content);
  }
    print("hello");
        print(123);
```

<T>代表泛型	如果对T类型进行约束: T extends Vehicle & Thing

`public class Test<U> {`
	`// 该方法只是使用了泛型类定义的类型参数，不是泛型方法`
	`public void testMethod(U u){`
		`System.out.println(u);`
	`}`
``	

	// <T> 真正声明了下面的方法是一个泛型方法
	public <T> T testMethod1(T t){
		return t;
	}
`}`

## 通配符(Wildcard)

通配符? : 匹配所有类型,. 

约束: ? extends Vehicle

​			下界通配符:  ? super Car  只能是Car的父类或其本身

​			



### 注解

@Data ： 注在类上，提供类的get、set、equals、hashCode、toString等方法
@AllArgsConstructor ：提供类的全参构造
@NoArgsConstructor ：提供类的无参构造
@Setter ：注在属性上，提供 set 方法
@Getter ：注在属性上，提供 get 方法
@EqualsAndHashCode ：注在类上，提供对应的 equals 和 hashCode 方法
@Log4j/@Slf4j ：注在类上，提供对应的 Logger 对象，变量名为 log