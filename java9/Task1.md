# Task1

**问题1:**

`List<String> strings = List.of("I", "am", "a", "list", "of", "Strings");`
`Stream<String> stream = strings.stream();`
`//调用流API的方法，例如我们希望最多有4个元素`
`Stream<String> limit = stream.limit(4);`
`//最后我们打印结果`
`System.out.println("limit = " + limit);`

没有直接打印出 limit 对象本身，而是返回一个新的 Stream<String> 实例，这个实例是一个**惰性计算流**(推迟了对象的初始化时间，直到真正需要使用该对象时才进行加载或初始化。可以提高程序的启动速度和响应速度)，表示的是对原始列表中前四个元素的操作序列

使用 `System.out.println("limit = " + limit)`; 打印 limit 变量时，实际上是在试图将 Stream<String> 类型转换为字符串输出。由于 limit 是一个流对象，并不是一个具体的列表或其他可以直接打印的集合，所以它会显示为内部类型的引用地址，也就是内存中的存储位置，而不是流中的元素集合。



## 补充学习: Lambda表达式

补充: **匿名内部类**是一种特殊的类形式，它在创建时无需为其指定名称，而是直接嵌套在另一个类、接口或者方法的定义中。它的主要用途是为了实现一些简单的功能，特别是作为回调函数或者是事件监听器等。

e.g.

`button.setOnClickListener(new View.OnClickListener() {`
    `@Override`
    `public void onClick(View v) {`
        `// 点击按钮的处理逻辑`
    `}`
`});`

**函数式编程思想:** 忽略对象的复杂语法, 强调做什么(强调处理逻辑)而不是谁去做

简化匿名内部类的书写,只能简化函数式接口的写法

**函数式接口**: 有且只有一个抽象方法		可加@FunctionalInterface注解

### 标准格式

() -> {}	()对应着方法的形参	-> 固定格式	{}对应方法体



## 操作堆叠
**操作堆叠**：这些操作会返回一个新的流，因此它们可以被堆叠起来。例如，map、filter、sorted等都是中间操作。它们不会立即执行，而是创建了一个新的流，这个流表示了一系列的惰性操作（lazy operations）。

**终端操作**：这些操作会触发流的遍历，并产生一个最终的结果或副作用。例如，collect、forEach、count等都是终端操作。一旦执行了终端操作，流就会被消费，不能再被使用。

## 流操作的规律
**链式调用**：中间操作可以链式调用，因为每个中间操作都返回一个新的流。这种链式调用的方式使得代码更加清晰和声明式。

**惰性执行**：流操作是惰性的，这意味着它们不会立即执行，而是在需要最终结果时才执行。这种惰性执行可以提高性能，因为它允许JVM优化操作的执行。

**消费流**：一旦流被消费（即执行了终端操作），流就不能再被使用。如果需要再次使用流，必须重新创建。

**不可变性**：流操作不会改变原始数据源，除非明确指定。例如，map操作会返回一个新的流，其中包含了映射后的结果，而不会改变原始流。



**附**:在使用 FileReader 读取文件时，定义一个整型变量 i 来存储每次 read() 方法的返回值有几个原因：

1.方法返回类型：FileReader 的 read() 方法返回的是 int 类型，而不是 char 类型。这是因为 read() 方法不仅返回文件中的字符，还**返回一个特殊值 -1** 来表示文件已经读取到末尾（EOF）。因此，需要一个 int 类型的变量来接收这个返回值。

2.字符编码：文件中的每个字符在计算机中都是以数字形式存储的，这是字符编码的一部分。int 类型的变量可以存储这些数字表示，而 char 类型只能存储有效的 Unicode 字符。

3.错误检测：返回值 -1 是一个重要的信号，表示已经到达文件的末尾。通过检查 int 变量 i 是否等于 -1，可以确定是否已经读取完文件的所有内容。

4.转换为字符：虽然 read() 方法返回的是 int 类型的值，但这个值实际上是字符的 Unicode 编码。通过将 int 类型的值强制转换为 char，可以得到原始的字符。